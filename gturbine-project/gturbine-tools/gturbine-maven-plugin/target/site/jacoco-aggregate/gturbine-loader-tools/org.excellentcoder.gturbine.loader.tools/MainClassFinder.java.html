<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MainClassFinder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">gturbine-maven-plugin</a> &gt; <a href="../index.html" class="el_bundle">gturbine-loader-tools</a> &gt; <a href="index.source.html" class="el_package">org.excellentcoder.gturbine.loader.tools</a> &gt; <span class="el_source">MainClassFinder.java</span></div><h1>MainClassFinder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.excellentcoder.gturbine.loader.tools;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import org.springframework.asm.AnnotationVisitor;
import org.springframework.asm.ClassReader;
import org.springframework.asm.ClassVisitor;
import org.springframework.asm.MethodVisitor;
import org.springframework.asm.Opcodes;
import org.springframework.asm.SpringAsmInfo;
import org.springframework.asm.Type;

/**
 * Finds any class with a {@code public static main} method by performing a breadth first
 * search.
 *
 * @author Phillip Webb
 * @author Andy Wilkinson
 * @since 1.0.0
 */
<span class="nc" id="L55">public abstract class MainClassFinder {</span>

	private static final String DOT_CLASS = &quot;.class&quot;;

<span class="nc" id="L59">	private static final Type STRING_ARRAY_TYPE = Type.getType(String[].class);</span>

<span class="nc" id="L61">	private static final Type MAIN_METHOD_TYPE = Type.getMethodType(Type.VOID_TYPE, STRING_ARRAY_TYPE);</span>

	private static final String MAIN_METHOD_NAME = &quot;main&quot;;

<span class="nc" id="L65">	private static final FileFilter CLASS_FILE_FILTER = MainClassFinder::isClassFile;</span>

<span class="nc" id="L67">	private static final FileFilter PACKAGE_FOLDER_FILTER = MainClassFinder::isPackageFolder;</span>

	private static boolean isClassFile(File file) {
<span class="nc bnc" id="L70" title="All 4 branches missed.">		return file.isFile() &amp;&amp; file.getName().endsWith(DOT_CLASS);</span>
	}

	private static boolean isPackageFolder(File file) {
<span class="nc bnc" id="L74" title="All 4 branches missed.">		return file.isDirectory() &amp;&amp; !file.getName().startsWith(&quot;.&quot;);</span>
	}

	/**
	 * Find the main class from a given folder.
	 * @param rootFolder the root folder to search
	 * @return the main class or {@code null}
	 * @throws IOException if the folder cannot be read
	 */
	public static String findMainClass(File rootFolder) throws IOException {
<span class="nc" id="L84">		return doWithMainClasses(rootFolder, MainClass::getName);</span>
	}

	/**
	 * Find a single main class from the given {@code rootFolder}.
	 * @param rootFolder the root folder to search
	 * @return the main class or {@code null}
	 * @throws IOException if the folder cannot be read
	 */
	public static String findSingleMainClass(File rootFolder) throws IOException {
<span class="nc" id="L94">		return findSingleMainClass(rootFolder, null);</span>
	}

	/**
	 * Find a single main class from the given {@code rootFolder}. A main class annotated
	 * with an annotation with the given {@code annotationName} will be preferred over a
	 * main class with no such annotation.
	 * @param rootFolder the root folder to search
	 * @param annotationName the name of the annotation that may be present on the main
	 * class
	 * @return the main class or {@code null}
	 * @throws IOException if the folder cannot be read
	 */
	public static String findSingleMainClass(File rootFolder, String annotationName) throws IOException {
<span class="nc" id="L108">		SingleMainClassCallback callback = new SingleMainClassCallback(annotationName);</span>
<span class="nc" id="L109">		MainClassFinder.doWithMainClasses(rootFolder, callback);</span>
<span class="nc" id="L110">		return callback.getMainClassName();</span>
	}

	/**
	 * Perform the given callback operation on all main classes from the given root
	 * folder.
	 * @param &lt;T&gt; the result type
	 * @param rootFolder the root folder
	 * @param callback the callback
	 * @return the first callback result or {@code null}
	 * @throws IOException in case of I/O errors
	 */
	static &lt;T&gt; T doWithMainClasses(File rootFolder, MainClassCallback&lt;T&gt; callback) throws IOException {
<span class="nc bnc" id="L123" title="All 2 branches missed.">		if (!rootFolder.exists()) {</span>
<span class="nc" id="L124">			return null; // nothing to do</span>
		}
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (!rootFolder.isDirectory()) {</span>
<span class="nc" id="L127">			throw new IllegalArgumentException(&quot;Invalid root folder '&quot; + rootFolder + &quot;'&quot;);</span>
		}
<span class="nc" id="L129">		String prefix = rootFolder.getAbsolutePath() + &quot;/&quot;;</span>
<span class="nc" id="L130">		Deque&lt;File&gt; stack = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L131">		stack.push(rootFolder);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		while (!stack.isEmpty()) {</span>
<span class="nc" id="L133">			File file = stack.pop();</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			if (file.isFile()) {</span>
<span class="nc" id="L135">				try (InputStream inputStream = new FileInputStream(file)) {</span>
<span class="nc" id="L136">					ClassDescriptor classDescriptor = createClassDescriptor(inputStream);</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">					if (classDescriptor != null &amp;&amp; classDescriptor.isMainMethodFound()) {</span>
<span class="nc" id="L138">						String className = convertToClassName(file.getAbsolutePath(), prefix);</span>
<span class="nc" id="L139">						T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames()));</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">						if (result != null) {</span>
<span class="nc" id="L141">							return result;</span>
						}
					}
<span class="nc bnc" id="L144" title="All 12 branches missed.">				}</span>
			}
<span class="nc bnc" id="L146" title="All 2 branches missed.">			if (file.isDirectory()) {</span>
<span class="nc" id="L147">				pushAllSorted(stack, file.listFiles(PACKAGE_FOLDER_FILTER));</span>
<span class="nc" id="L148">				pushAllSorted(stack, file.listFiles(CLASS_FILE_FILTER));</span>
			}
<span class="nc" id="L150">		}</span>
<span class="nc" id="L151">		return null;</span>
	}

	private static void pushAllSorted(Deque&lt;File&gt; stack, File[] files) {
<span class="nc" id="L155">		Arrays.sort(files, Comparator.comparing(File::getName));</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">		for (File file : files) {</span>
<span class="nc" id="L157">			stack.push(file);</span>
		}
<span class="nc" id="L159">	}</span>

	/**
	 * Find the main class in a given jar file.
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @return the main class or {@code null}
	 * @throws IOException if the jar file cannot be read
	 */
	public static String findMainClass(JarFile jarFile, String classesLocation) throws IOException {
<span class="nc" id="L169">		return doWithMainClasses(jarFile, classesLocation, MainClass::getName);</span>
	}

	/**
	 * Find a single main class in a given jar file.
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @return the main class or {@code null}
	 * @throws IOException if the jar file cannot be read
	 */
	public static String findSingleMainClass(JarFile jarFile, String classesLocation) throws IOException {
<span class="nc" id="L180">		return findSingleMainClass(jarFile, classesLocation, null);</span>
	}

	/**
	 * Find a single main class in a given jar file. A main class annotated with an
	 * annotation with the given {@code annotationName} will be preferred over a main
	 * class with no such annotation.
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @param annotationName the name of the annotation that may be present on the main
	 * class
	 * @return the main class or {@code null}
	 * @throws IOException if the jar file cannot be read
	 */
	public static String findSingleMainClass(JarFile jarFile, String classesLocation, String annotationName)
			throws IOException {
<span class="nc" id="L196">		SingleMainClassCallback callback = new SingleMainClassCallback(annotationName);</span>
<span class="nc" id="L197">		MainClassFinder.doWithMainClasses(jarFile, classesLocation, callback);</span>
<span class="nc" id="L198">		return callback.getMainClassName();</span>
	}

	/**
	 * Perform the given callback operation on all main classes from the given jar.
	 * @param &lt;T&gt; the result type
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @param callback the callback
	 * @return the first callback result or {@code null}
	 * @throws IOException in case of I/O errors
	 */
	static &lt;T&gt; T doWithMainClasses(JarFile jarFile, String classesLocation, MainClassCallback&lt;T&gt; callback)
			throws IOException {
<span class="nc" id="L212">		List&lt;JarEntry&gt; classEntries = getClassEntries(jarFile, classesLocation);</span>
<span class="nc" id="L213">		classEntries.sort(new ClassEntryComparator());</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		for (JarEntry entry : classEntries) {</span>
<span class="nc" id="L215">			try (InputStream inputStream = new BufferedInputStream(jarFile.getInputStream(entry))) {</span>
<span class="nc" id="L216">				ClassDescriptor classDescriptor = createClassDescriptor(inputStream);</span>
<span class="nc bnc" id="L217" title="All 4 branches missed.">				if (classDescriptor != null &amp;&amp; classDescriptor.isMainMethodFound()) {</span>
<span class="nc" id="L218">					String className = convertToClassName(entry.getName(), classesLocation);</span>
<span class="nc" id="L219">					T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames()));</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">					if (result != null) {</span>
<span class="nc" id="L221">						return result;</span>
					}
				}
<span class="nc bnc" id="L224" title="All 12 branches missed.">			}</span>
<span class="nc" id="L225">		}</span>
<span class="nc" id="L226">		return null;</span>
	}

	private static String convertToClassName(String name, String prefix) {
<span class="nc" id="L230">		name = name.replace('/', '.');</span>
<span class="nc" id="L231">		name = name.replace('\\', '.');</span>
<span class="nc" id="L232">		name = name.substring(0, name.length() - DOT_CLASS.length());</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">		if (prefix != null) {</span>
<span class="nc" id="L234">			name = name.substring(prefix.length());</span>
		}
<span class="nc" id="L236">		return name;</span>
	}

	private static List&lt;JarEntry&gt; getClassEntries(JarFile source, String classesLocation) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">		classesLocation = (classesLocation != null) ? classesLocation : &quot;&quot;;</span>
<span class="nc" id="L241">		Enumeration&lt;JarEntry&gt; sourceEntries = source.entries();</span>
<span class="nc" id="L242">		List&lt;JarEntry&gt; classEntries = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">		while (sourceEntries.hasMoreElements()) {</span>
<span class="nc" id="L244">			JarEntry entry = sourceEntries.nextElement();</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">			if (entry.getName().startsWith(classesLocation) &amp;&amp; entry.getName().endsWith(DOT_CLASS)) {</span>
<span class="nc" id="L246">				classEntries.add(entry);</span>
			}
<span class="nc" id="L248">		}</span>
<span class="nc" id="L249">		return classEntries;</span>
	}

	private static ClassDescriptor createClassDescriptor(InputStream inputStream) {
		try {
<span class="nc" id="L254">			ClassReader classReader = new ClassReader(inputStream);</span>
<span class="nc" id="L255">			ClassDescriptor classDescriptor = new ClassDescriptor();</span>
<span class="nc" id="L256">			classReader.accept(classDescriptor, ClassReader.SKIP_CODE);</span>
<span class="nc" id="L257">			return classDescriptor;</span>
		}
<span class="nc" id="L259">		catch (IOException ex) {</span>
<span class="nc" id="L260">			return null;</span>
		}
	}

<span class="nc" id="L264">	private static class ClassEntryComparator implements Comparator&lt;JarEntry&gt; {</span>

		@Override
		public int compare(JarEntry o1, JarEntry o2) {
<span class="nc" id="L268">			Integer d1 = getDepth(o1);</span>
<span class="nc" id="L269">			Integer d2 = getDepth(o2);</span>
<span class="nc" id="L270">			int depthCompare = d1.compareTo(d2);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">			if (depthCompare != 0) {</span>
<span class="nc" id="L272">				return depthCompare;</span>
			}
<span class="nc" id="L274">			return o1.getName().compareTo(o2.getName());</span>
		}

		private int getDepth(JarEntry entry) {
<span class="nc" id="L278">			return entry.getName().split(&quot;/&quot;).length;</span>
		}

	}

	private static class ClassDescriptor extends ClassVisitor {

<span class="nc" id="L285">		private final Set&lt;String&gt; annotationNames = new LinkedHashSet&lt;&gt;();</span>

		private boolean mainMethodFound;

		ClassDescriptor() {
<span class="nc" id="L290">			super(SpringAsmInfo.ASM_VERSION);</span>
<span class="nc" id="L291">		}</span>

		@Override
		public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
<span class="nc" id="L295">			this.annotationNames.add(Type.getType(desc).getClassName());</span>
<span class="nc" id="L296">			return null;</span>
		}

		@Override
		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
<span class="nc bnc" id="L301" title="All 4 branches missed.">			if (isAccess(access, Opcodes.ACC_PUBLIC, Opcodes.ACC_STATIC) &amp;&amp; MAIN_METHOD_NAME.equals(name)</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">					&amp;&amp; MAIN_METHOD_TYPE.getDescriptor().equals(desc)) {</span>
<span class="nc" id="L303">				this.mainMethodFound = true;</span>
			}
<span class="nc" id="L305">			return null;</span>
		}

		private boolean isAccess(int access, int... requiredOpsCodes) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">			for (int requiredOpsCode : requiredOpsCodes) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">				if ((access &amp; requiredOpsCode) == 0) {</span>
<span class="nc" id="L311">					return false;</span>
				}
			}
<span class="nc" id="L314">			return true;</span>
		}

		boolean isMainMethodFound() {
<span class="nc" id="L318">			return this.mainMethodFound;</span>
		}

		Set&lt;String&gt; getAnnotationNames() {
<span class="nc" id="L322">			return this.annotationNames;</span>
		}

	}

	/**
	 * Callback for handling {@link MainClass MainClasses}.
	 *
	 * @param &lt;T&gt; the callback's return type
	 */
	interface MainClassCallback&lt;T&gt; {

		/**
		 * Handle the specified main class.
		 * @param mainClass the main class
		 * @return a non-null value if processing should end or {@code null} to continue
		 */
		T doWith(MainClass mainClass);

	}

	/**
	 * A class with a {@code main} method.
	 */
	static final class MainClass {

		private final String name;

		private final Set&lt;String&gt; annotationNames;

		/**
		 * Creates a new {@code MainClass} rather represents the main class with the given
		 * {@code name}. The class is annotated with the annotations with the given
		 * {@code annotationNames}.
		 * @param name the name of the class
		 * @param annotationNames the names of the annotations on the class
		 */
<span class="nc" id="L359">		MainClass(String name, Set&lt;String&gt; annotationNames) {</span>
<span class="nc" id="L360">			this.name = name;</span>
<span class="nc" id="L361">			this.annotationNames = Collections.unmodifiableSet(new HashSet&lt;&gt;(annotationNames));</span>
<span class="nc" id="L362">		}</span>

		String getName() {
<span class="nc" id="L365">			return this.name;</span>
		}

		Set&lt;String&gt; getAnnotationNames() {
<span class="nc" id="L369">			return this.annotationNames;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L375">				return true;</span>
			}
<span class="nc bnc" id="L377" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L378">				return false;</span>
			}
<span class="nc bnc" id="L380" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L381">				return false;</span>
			}
<span class="nc" id="L383">			MainClass other = (MainClass) obj;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">			if (!this.name.equals(other.name)) {</span>
<span class="nc" id="L385">				return false;</span>
			}
<span class="nc" id="L387">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L392">			return this.name.hashCode();</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L397">			return this.name;</span>
		}

	}

	/**
	 * Find a single main class, throwing an {@link IllegalStateException} if multiple
	 * candidates exist.
	 */
	private static final class SingleMainClassCallback implements MainClassCallback&lt;Object&gt; {

<span class="nc" id="L408">		private final Set&lt;MainClass&gt; mainClasses = new LinkedHashSet&lt;&gt;();</span>

		private final String annotationName;

<span class="nc" id="L412">		private SingleMainClassCallback(String annotationName) {</span>
<span class="nc" id="L413">			this.annotationName = annotationName;</span>
<span class="nc" id="L414">		}</span>

		@Override
		public Object doWith(MainClass mainClass) {
<span class="nc" id="L418">			this.mainClasses.add(mainClass);</span>
<span class="nc" id="L419">			return null;</span>
		}

		private String getMainClassName() {
<span class="nc" id="L423">			Set&lt;MainClass&gt; matchingMainClasses = new LinkedHashSet&lt;&gt;();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">			if (this.annotationName != null) {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">				for (MainClass mainClass : this.mainClasses) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">					if (mainClass.getAnnotationNames().contains(this.annotationName)) {</span>
<span class="nc" id="L427">						matchingMainClasses.add(mainClass);</span>
					}
<span class="nc" id="L429">				}</span>
			}
<span class="nc bnc" id="L431" title="All 2 branches missed.">			if (matchingMainClasses.isEmpty()) {</span>
<span class="nc" id="L432">				matchingMainClasses.addAll(this.mainClasses);</span>
			}
<span class="nc bnc" id="L434" title="All 2 branches missed.">			if (matchingMainClasses.size() &gt; 1) {</span>
<span class="nc" id="L435">				throw new IllegalStateException(</span>
						&quot;Unable to find a single main class from the following candidates &quot; + matchingMainClasses);
			}
<span class="nc bnc" id="L438" title="All 2 branches missed.">			return (matchingMainClasses.isEmpty() ? null : matchingMainClasses.iterator().next().getName());</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>