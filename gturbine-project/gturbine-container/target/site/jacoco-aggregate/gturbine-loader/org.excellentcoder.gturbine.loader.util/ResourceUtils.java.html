<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ResourceUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">gturbine-container</a> &gt; <a href="../index.html" class="el_bundle">gturbine-loader</a> &gt; <a href="index.source.html" class="el_package">org.excellentcoder.gturbine.loader.util</a> &gt; <span class="el_source">ResourceUtils.java</span></div><h1>ResourceUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.excellentcoder.gturbine.loader.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLConnection;

/**
 * Utility methods for resolving resource locations to files in the
 * file system. Mainly for internal use within the framework.
 *
 * &lt;p&gt;Consider using Spring's Resource abstraction in the core package
 * for handling all kinds of file resources in a uniform manner.
 * {org.springframework.core.io.ResourceLoader}'s {@code getResource()}
 * method can resolve any location to a {org.springframework.core.io.Resource}
 * object, which in turn allows one to obtain a {@code java.io.File} in the
 * file system through its {@code getFile()} method.
 *
 * @author Juergen Hoeller
 * @since 1.1.5
 */
<span class="nc" id="L41">public abstract class ResourceUtils {</span>

    /** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;. */
    public static final String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;;

    /** URL prefix for loading from the file system: &quot;file:&quot;. */
    public static final String FILE_URL_PREFIX      = &quot;file:&quot;;

    /** URL prefix for loading from a jar file: &quot;jar:&quot;. */
    public static final String JAR_URL_PREFIX       = &quot;jar:&quot;;

    /** URL prefix for loading from a war file on Tomcat: &quot;war:&quot;. */
    public static final String WAR_URL_PREFIX       = &quot;war:&quot;;

    /** URL protocol for a file in the file system: &quot;file&quot;. */
    public static final String URL_PROTOCOL_FILE    = &quot;file&quot;;

    /** URL protocol for an entry from a jar file: &quot;jar&quot;. */
    public static final String URL_PROTOCOL_JAR     = &quot;jar&quot;;

    /** URL protocol for an entry from a war file: &quot;war&quot;. */
    public static final String URL_PROTOCOL_WAR     = &quot;war&quot;;

    /** URL protocol for an entry from a zip file: &quot;zip&quot;. */
    public static final String URL_PROTOCOL_ZIP     = &quot;zip&quot;;

    /** URL protocol for an entry from a WebSphere jar file: &quot;wsjar&quot;. */
    public static final String URL_PROTOCOL_WSJAR   = &quot;wsjar&quot;;

    /** URL protocol for an entry from a JBoss jar file: &quot;vfszip&quot;. */
    public static final String URL_PROTOCOL_VFSZIP  = &quot;vfszip&quot;;

    /** URL protocol for a JBoss file system resource: &quot;vfsfile&quot;. */
    public static final String URL_PROTOCOL_VFSFILE = &quot;vfsfile&quot;;

    /** URL protocol for a general JBoss VFS resource: &quot;vfs&quot;. */
    public static final String URL_PROTOCOL_VFS     = &quot;vfs&quot;;

    /** File extension for a regular jar file: &quot;.jar&quot;. */
    public static final String JAR_FILE_EXTENSION   = &quot;.jar&quot;;

    /** Separator between JAR URL and file path within the JAR: &quot;!/&quot;. */
    public static final String JAR_URL_SEPARATOR    = &quot;!/&quot;;

    /** Special separator between WAR URL and jar part on Tomcat. */
    public static final String WAR_URL_SEPARATOR    = &quot;*/&quot;;

    /**
     * Assert that an object is not {@code null}.
     * &lt;pre class=&quot;code&quot;&gt;Assert.notNull(clazz, &quot;The class must not be null&quot;);&lt;/pre&gt;
     * @param object the object to check
     * @param message the exception message to use if the assertion fails
     * @throws IllegalArgumentException if the object is {@code null}
     */
    public static void notNull(Object object, String message) {
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L97">            throw new IllegalArgumentException(message);</span>
        }
<span class="nc" id="L99">    }</span>

    /**
     * Return whether the given resource location is a URL:
     * either a special &quot;classpath&quot; pseudo URL or a standard URL.
     * @param resourceLocation the location String to check
     * @return whether the location qualifies as a URL
     * @see #CLASSPATH_URL_PREFIX
     * @see java.net.URL
     */
    public static boolean isUrl(String resourceLocation) {
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (resourceLocation == null) {</span>
<span class="nc" id="L111">            return false;</span>
        }
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {</span>
<span class="nc" id="L114">            return true;</span>
        }
        try {
<span class="nc" id="L117">            new URL(resourceLocation);</span>
<span class="nc" id="L118">            return true;</span>
<span class="nc" id="L119">        } catch (MalformedURLException ex) {</span>
<span class="nc" id="L120">            return false;</span>
        }
    }

    /**
     * Resolve the given resource location to a {@code java.net.URL}.
     * &lt;p&gt;Does not check whether the URL actually exists; simply returns
     * the URL that the given location would correspond to.
     * @param resourceLocation the resource location to resolve: either a
     * &quot;classpath:&quot; pseudo URL, a &quot;file:&quot; URL, or a plain file path
     * @return a corresponding URL object
     * @throws FileNotFoundException if the resource cannot be resolved to a URL
     */
    public static URL getURL(String resourceLocation) throws FileNotFoundException {
<span class="nc" id="L134">        notNull(resourceLocation, &quot;Resource location must not be null&quot;);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {</span>
<span class="nc" id="L136">            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());</span>
<span class="nc" id="L137">            ClassLoader cl = ClassUtils.getDefaultClassLoader();</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (url == null) {</span>
<span class="nc" id="L140">                String description = &quot;class path resource [&quot; + path + &quot;]&quot;;</span>
<span class="nc" id="L141">                throw new FileNotFoundException(</span>
                    description + &quot; cannot be resolved to URL because it does not exist&quot;);
            }
<span class="nc" id="L144">            return url;</span>
        }
        try {
            // try URL
<span class="nc" id="L148">            return new URL(resourceLocation);</span>
<span class="nc" id="L149">        } catch (MalformedURLException ex) {</span>
            // no URL -&gt; treat as file path
            try {
<span class="nc" id="L152">                return new File(resourceLocation).toURI().toURL();</span>
<span class="nc" id="L153">            } catch (MalformedURLException ex2) {</span>
<span class="nc" id="L154">                throw new FileNotFoundException(&quot;Resource location [&quot; + resourceLocation</span>
                                                + &quot;] is neither a URL not a well-formed file path&quot;);
            }
        }
    }

    /**
     * Resolve the given resource location to a {@code java.io.File},
     * i.e. to a file in the file system.
     * &lt;p&gt;Does not check whether the file actually exists; simply returns
     * the File that the given location would correspond to.
     * @param resourceLocation the resource location to resolve: either a
     * &quot;classpath:&quot; pseudo URL, a &quot;file:&quot; URL, or a plain file path
     * @return a corresponding File object
     * @throws FileNotFoundException if the resource cannot be resolved to
     * a file in the file system
     */
    public static File getFile(String resourceLocation) throws FileNotFoundException {
<span class="nc" id="L172">        notNull(resourceLocation, &quot;Resource location must not be null&quot;);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {</span>
<span class="nc" id="L174">            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());</span>
<span class="nc" id="L175">            String description = &quot;class path resource [&quot; + path + &quot;]&quot;;</span>
<span class="nc" id="L176">            ClassLoader cl = ClassUtils.getDefaultClassLoader();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (url == null) {</span>
<span class="nc" id="L179">                throw new FileNotFoundException(</span>
                    description
                            + &quot; cannot be resolved to absolute file path because it does not exist&quot;);
            }
<span class="nc" id="L183">            return getFile(url, description);</span>
        }
        try {
            // try URL
<span class="nc" id="L187">            return getFile(new URL(resourceLocation));</span>
<span class="nc" id="L188">        } catch (MalformedURLException ex) {</span>
            // no URL -&gt; treat as file path
<span class="nc" id="L190">            return new File(resourceLocation);</span>
        }
    }

    /**
     * Resolve the given resource URL to a {@code java.io.File},
     * i.e. to a file in the file system.
     * @param resourceUrl the resource URL to resolve
     * @return a corresponding File object
     * @throws FileNotFoundException if the URL cannot be resolved to
     * a file in the file system
     */
    public static File getFile(URL resourceUrl) throws FileNotFoundException {
<span class="nc" id="L203">        return getFile(resourceUrl, &quot;URL&quot;);</span>
    }

    /**
     * Resolve the given resource URL to a {@code java.io.File},
     * i.e. to a file in the file system.
     * @param resourceUrl the resource URL to resolve
     * @param description a description of the original resource that
     * the URL was created for (for example, a class path location)
     * @return a corresponding File object
     * @throws FileNotFoundException if the URL cannot be resolved to
     * a file in the file system
     */
    public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {
<span class="nc" id="L217">        notNull(resourceUrl, &quot;Resource URL must not be null&quot;);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {</span>
<span class="nc" id="L219">            throw new FileNotFoundException(description</span>
                                            + &quot; cannot be resolved to absolute file path &quot;
                                            + &quot;because it does not reside in the file system: &quot;
                                            + resourceUrl);
        }
        try {
<span class="nc" id="L225">            return new File(toURI(resourceUrl).getSchemeSpecificPart());</span>
<span class="nc" id="L226">        } catch (URISyntaxException ex) {</span>
            // Fallback for URLs that are not valid URIs (should hardly ever happen).
<span class="nc" id="L228">            return new File(resourceUrl.getFile());</span>
        }
    }

    /**
     * Resolve the given resource URI to a {@code java.io.File},
     * i.e. to a file in the file system.
     * @param resourceUri the resource URI to resolve
     * @return a corresponding File object
     * @throws FileNotFoundException if the URL cannot be resolved to
     * a file in the file system
     * @since 2.5
     */
    public static File getFile(URI resourceUri) throws FileNotFoundException {
<span class="nc" id="L242">        return getFile(resourceUri, &quot;URI&quot;);</span>
    }

    /**
     * Resolve the given resource URI to a {@code java.io.File},
     * i.e. to a file in the file system.
     * @param resourceUri the resource URI to resolve
     * @param description a description of the original resource that
     * the URI was created for (for example, a class path location)
     * @return a corresponding File object
     * @throws FileNotFoundException if the URL cannot be resolved to
     * a file in the file system
     * @since 2.5
     */
    public static File getFile(URI resourceUri, String description) throws FileNotFoundException {
<span class="nc" id="L257">        notNull(resourceUri, &quot;Resource URI must not be null&quot;);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {</span>
<span class="nc" id="L259">            throw new FileNotFoundException(description</span>
                                            + &quot; cannot be resolved to absolute file path &quot;
                                            + &quot;because it does not reside in the file system: &quot;
                                            + resourceUri);
        }
<span class="nc" id="L264">        return new File(resourceUri.getSchemeSpecificPart());</span>
    }

    /**
     * Determine whether the given URL points to a resource in the file system,
     * i.e. has protocol &quot;file&quot;, &quot;vfsfile&quot; or &quot;vfs&quot;.
     * @param url the URL to check
     * @return whether the URL has been identified as a file system URL
     */
    public static boolean isFileURL(URL url) {
<span class="nc" id="L274">        String protocol = url.getProtocol();</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">        return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol) || URL_PROTOCOL_VFS</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            .equals(protocol));</span>
    }

    /**
     * Determine whether the given URL points to a resource in a jar file.
     * i.e. has protocol &quot;jar&quot;, &quot;war, &quot;&quot;zip&quot;, &quot;vfszip&quot; or &quot;wsjar&quot;.
     * @param url the URL to check
     * @return whether the URL has been identified as a JAR URL
     */
    public static boolean isJarURL(URL url) {
<span class="nc" id="L286">        String protocol = url.getProtocol();</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">        return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_WAR.equals(protocol)</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">                || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            .equals(protocol));</span>
    }

    /**
     * Determine whether the given URL points to a jar file itself,
     * that is, has protocol &quot;file&quot; and ends with the &quot;.jar&quot; extension.
     * @param url the URL to check
     * @return whether the URL has been identified as a JAR file URL
     * @since 4.1
     */
    public static boolean isJarFileURL(URL url) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        return (URL_PROTOCOL_FILE.equals(url.getProtocol()) &amp;&amp; url.getPath().toLowerCase()</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            .endsWith(JAR_FILE_EXTENSION));</span>
    }

    /**
     * Extract the URL for the actual jar file from the given URL
     * (which may point to a resource in a jar file or to a jar file itself).
     * @param jarUrl the original URL
     * @return the URL for the actual jar file
     * @throws MalformedURLException if no valid jar file URL could be extracted
     */
    public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {
<span class="nc" id="L312">        String urlFile = jarUrl.getFile();</span>
<span class="nc" id="L313">        int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (separatorIndex != -1) {</span>
<span class="nc" id="L315">            String jarFile = urlFile.substring(0, separatorIndex);</span>
            try {
<span class="nc" id="L317">                return new URL(jarFile);</span>
<span class="nc" id="L318">            } catch (MalformedURLException ex) {</span>
                // Probably no protocol in original jar URL, like &quot;jar:C:/mypath/myjar.jar&quot;.
                // This usually indicates that the jar file resides in the file system.
<span class="nc bnc" id="L321" title="All 2 branches missed.">                if (!jarFile.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L322">                    jarFile = &quot;/&quot; + jarFile;</span>
                }
<span class="nc" id="L324">                return new URL(FILE_URL_PREFIX + jarFile);</span>
            }
        } else {
<span class="nc" id="L327">            return jarUrl;</span>
        }
    }

    /**
     * Extract the URL for the outermost archive from the given jar/war URL
     * (which may point to a resource in a jar file or to a jar file itself).
     * &lt;p&gt;In the case of a jar file nested within a war file, this will return
     * a URL to the war file since that is the one resolvable in the file system.
     * @param jarUrl the original URL
     * @return the URL for the actual jar file
     * @throws MalformedURLException if no valid jar file URL could be extracted
     * @since 4.1.8
     * @see #extractJarFileURL(URL)
     */
    public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {
<span class="nc" id="L343">        String urlFile = jarUrl.getFile();</span>

<span class="nc" id="L345">        int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (endIndex != -1) {</span>
            // Tomcat's &quot;war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt&quot;
<span class="nc" id="L348">            String warFile = urlFile.substring(0, endIndex);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {</span>
<span class="nc" id="L350">                return new URL(warFile);</span>
            }
<span class="nc" id="L352">            int startIndex = warFile.indexOf(WAR_URL_PREFIX);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (startIndex != -1) {</span>
<span class="nc" id="L354">                return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));</span>
            }
        }

        // Regular &quot;jar:file:...myjar.jar!/myentry.txt&quot;
<span class="nc" id="L359">        return extractJarFileURL(jarUrl);</span>
    }

    /**
     * Create a URI instance for the given URL,
     * replacing spaces with &quot;%20&quot; URI encoding first.
     * @param url the URL to convert into a URI instance
     * @return the URI instance
     * @throws URISyntaxException if the URL wasn't a valid URI
     * @see java.net.URL#toURI()
     */
    public static URI toURI(URL url) throws URISyntaxException {
<span class="nc" id="L371">        return toURI(url.toString());</span>
    }

    /**
     * Create a URI instance for the given location String,
     * replacing spaces with &quot;%20&quot; URI encoding first.
     * @param location the location String to convert into a URI instance
     * @return the URI instance
     * @throws URISyntaxException if the location wasn't a valid URI
     */
    public static URI toURI(String location) throws URISyntaxException {
<span class="nc" id="L382">        return new URI(replace(location, &quot; &quot;, &quot;%20&quot;));</span>
    }

    /**
     * Set the {@link URLConnection#setUseCaches &quot;useCaches&quot;} flag on the
     * given connection, preferring {@code false} but leaving the
     * flag at {@code true} for JNLP based resources.
     * @param con the URLConnection to set the flag on
     */
    public static void useCachesIfNecessary(URLConnection con) {
<span class="nc" id="L392">        con.setUseCaches(con.getClass().getSimpleName().startsWith(&quot;JNLP&quot;));</span>
<span class="nc" id="L393">    }</span>

    /**
     * Replace all occurrences of a substring within a string with another string.
     * @param inString {@code String} to examine
     * @param oldPattern {@code String} to replace
     * @param newPattern {@code String} to insert
     * @return a {@code String} with the replacements
     */
    public static String replace(String inString, String oldPattern, String newPattern) {
<span class="nc bnc" id="L403" title="All 6 branches missed.">        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {</span>
<span class="nc" id="L404">            return inString;</span>
        }
<span class="nc" id="L406">        int index = inString.indexOf(oldPattern);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (index == -1) {</span>
            // no occurrence -&gt; can return input as-is
<span class="nc" id="L409">            return inString;</span>
        }

<span class="nc" id="L412">        int capacity = inString.length();</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (newPattern.length() &gt; oldPattern.length()) {</span>
<span class="nc" id="L414">            capacity += 16;</span>
        }
<span class="nc" id="L416">        StringBuilder sb = new StringBuilder(capacity);</span>

<span class="nc" id="L418">        int pos = 0; // our position in the old string</span>
<span class="nc" id="L419">        int patLen = oldPattern.length();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        while (index &gt;= 0) {</span>
<span class="nc" id="L421">            sb.append(inString, pos, index);</span>
<span class="nc" id="L422">            sb.append(newPattern);</span>
<span class="nc" id="L423">            pos = index + patLen;</span>
<span class="nc" id="L424">            index = inString.indexOf(oldPattern, pos);</span>
        }

        // append any characters to the right of a match
<span class="nc" id="L428">        sb.append(inString, pos, inString.length());</span>
<span class="nc" id="L429">        return sb.toString();</span>
    }

    /**
     * Check that the given {@code String} is neither {@code null} nor of length 0.
     * &lt;p&gt;Note: this method returns {@code true} for a {@code String} that
     * purely consists of whitespace.
     * @param str the {@code String} to check (may be {@code null})
     * @return {@code true} if the {@code String} is not {@code null} and has length
     */
    public static boolean hasLength(String str) {
<span class="nc bnc" id="L440" title="All 4 branches missed.">        return (str != null &amp;&amp; !str.isEmpty());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>